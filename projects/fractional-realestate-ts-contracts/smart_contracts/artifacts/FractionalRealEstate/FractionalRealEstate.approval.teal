#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 8 1 0 32
    bytecblock "properties" 0x0042 0x151f7c75
    // smart_contracts/FractionalRealEstate/contract.algo.ts:27
    // export default class FractionalRealEstate extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@11
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x331dac54 0x0a3de51c 0x3b9e3945 0xf3ce5184 // method "createPropertyListing(pay,string,uint64,uint64)uint64", method "purchaseFromLister(uint64,uint64,pay)bool", method "delistProperty(uint64)void", method "getPropertyInfo(uint64)(string,uint64,uint64,uint64,uint64,address)"
    txna ApplicationArgs 0
    match createPropertyListing purchaseFromLister delistProperty getPropertyInfo
    err

main___algots__.defaultCreate@11:
    // smart_contracts/FractionalRealEstate/contract.algo.ts:27
    // export default class FractionalRealEstate extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts/FractionalRealEstate/contract.algo.ts::FractionalRealEstate.createPropertyListing[routing]() -> void:
createPropertyListing:
    // smart_contracts/FractionalRealEstate/contract.algo.ts:36-41
    // public createPropertyListing(
    //   mbrPayment: gtxn.PaymentTxn,
    //   propertyAddress: string,
    //   shares: uint64,
    //   pricePerShare: uint64,
    // ): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    dup
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    dup
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_0 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    dup
    btoi
    // smart_contracts/FractionalRealEstate/contract.algo.ts:42
    // assert(shares > 0, 'Shares must be greater than 0')
    dig 2
    assert // Shares must be greater than 0
    // smart_contracts/FractionalRealEstate/contract.algo.ts:43
    // assert(pricePerShare > 0, 'Price per share must be greater than 0')
    assert // Price per share must be greater than 0
    // smart_contracts/FractionalRealEstate/contract.algo.ts:53
    // const boxMbrCost: uint64 = 2500 + 400 * (18 + 68 + Bytes(propertyAddress).length)
    dig 3
    len
    pushint 86 // 86
    dig 1
    +
    pushint 400 // 400
    *
    pushint 2500 // 2500
    +
    // smart_contracts/FractionalRealEstate/contract.algo.ts:54
    // assert(mbrPayment.amount >= boxMbrCost, 'MBR payment amount is insufficient')
    dig 7
    gtxns Amount
    <=
    assert // MBR payment amount is insufficient
    // smart_contracts/FractionalRealEstate/contract.algo.ts:55
    // assert(mbrPayment.receiver === Global.currentApplicationAddress, 'MBR payment must be to the app')
    dig 6
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // MBR payment must be to the app
    // smart_contracts/FractionalRealEstate/contract.algo.ts:56
    // assert(mbrPayment.sender === Txn.sender, 'MBR payment must be from the caller')
    uncover 6
    gtxns Sender
    txn Sender
    ==
    assert // MBR payment must be from the caller
    // smart_contracts/FractionalRealEstate/contract.algo.ts:76-86
    // const txnResult = itxn
    //   .assetConfig({
    //     assetName: Bytes(propertyAddress).slice(0, 32).toString(),
    //     unitName: 'PROP',
    //     total: shares,
    //     decimals: 0,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/FractionalRealEstate/contract.algo.ts:78
    // assetName: Bytes(propertyAddress).slice(0, 32).toString(),
    intc_2 // 0
    dig 1
    >=
    intc_2 // 0
    dig 2
    uncover 2
    select
    intc_3 // 32
    dig 2
    >=
    intc_3 // 32
    uncover 3
    uncover 2
    select
    uncover 5
    cover 2
    substring3
    // smart_contracts/FractionalRealEstate/contract.algo.ts:82
    // manager: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/FractionalRealEstate/contract.algo.ts:83
    // reserve: Global.currentApplicationAddress,
    dup
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // smart_contracts/FractionalRealEstate/contract.algo.ts:81
    // decimals: 0,
    intc_2 // 0
    itxn_field ConfigAssetDecimals
    uncover 2
    itxn_field ConfigAssetTotal
    // smart_contracts/FractionalRealEstate/contract.algo.ts:79
    // unitName: 'PROP',
    pushbytes "PROP"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // smart_contracts/FractionalRealEstate/contract.algo.ts:76-85
    // const txnResult = itxn
    //   .assetConfig({
    //     assetName: Bytes(propertyAddress).slice(0, 32).toString(),
    //     unitName: 'PROP',
    //     total: shares,
    //     decimals: 0,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    pushint 3 // 3
    itxn_field TypeEnum
    // smart_contracts/FractionalRealEstate/contract.algo.ts:84
    // fee: 0,
    intc_2 // 0
    itxn_field Fee
    // smart_contracts/FractionalRealEstate/contract.algo.ts:76-86
    // const txnResult = itxn
    //   .assetConfig({
    //     assetName: Bytes(propertyAddress).slice(0, 32).toString(),
    //     unitName: 'PROP',
    //     total: shares,
    //     decimals: 0,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/FractionalRealEstate/contract.algo.ts:65
    // propertyAssetId: new arc4.Uint64(assetId),
    itob
    // smart_contracts/FractionalRealEstate/contract.algo.ts:66
    // ownerAddress: new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/FractionalRealEstate/contract.algo.ts:60-67
    // const propertyStruct = new PropertyStruct({
    //   address: new arc4.Str(propertyAddress),
    //   totalShares: new arc4.Uint64(shares),
    //   availableShares: new arc4.Uint64(shares),
    //   pricePerShare: new arc4.Uint64(pricePerShare),
    //   propertyAssetId: new arc4.Uint64(assetId),
    //   ownerAddress: new arc4.Address(Txn.sender),
    // })
    bytec_1 // 0x0042
    dig 4
    concat
    uncover 4
    concat
    uncover 3
    concat
    dig 2
    concat
    swap
    concat
    uncover 2
    concat
    // smart_contracts/FractionalRealEstate/contract.algo.ts:28
    // public listedProperties = BoxMap<uint64, PropertyStruct>({ keyPrefix: 'properties' })
    bytec_0 // "properties"
    dig 2
    concat
    // smart_contracts/FractionalRealEstate/contract.algo.ts:69
    // this.listedProperties(assetId).value = clone(propertyStruct)
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/FractionalRealEstate/contract.algo.ts:36-41
    // public createPropertyListing(
    //   mbrPayment: gtxn.PaymentTxn,
    //   propertyAddress: string,
    //   shares: uint64,
    //   pricePerShare: uint64,
    // ): uint64 {
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/FractionalRealEstate/contract.algo.ts::FractionalRealEstate.purchaseFromLister[routing]() -> void:
purchaseFromLister:
    // smart_contracts/FractionalRealEstate/contract.algo.ts:92
    // public purchaseFromLister(propertyId: uint64, shares: uint64, payment: gtxn.PaymentTxn): boolean {
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/FractionalRealEstate/contract.algo.ts:93
    // assert(shares > 0, 'Must purchase at least one share')
    dig 1
    assert // Must purchase at least one share
    // smart_contracts/FractionalRealEstate/contract.algo.ts:94
    // assert(this.listedProperties(propertyId).exists, 'Property not listed')
    uncover 2
    itob
    // smart_contracts/FractionalRealEstate/contract.algo.ts:28
    // public listedProperties = BoxMap<uint64, PropertyStruct>({ keyPrefix: 'properties' })
    bytec_0 // "properties"
    swap
    concat
    // smart_contracts/FractionalRealEstate/contract.algo.ts:94
    // assert(this.listedProperties(propertyId).exists, 'Property not listed')
    dup
    box_len
    bury 1
    assert // Property not listed
    // smart_contracts/FractionalRealEstate/contract.algo.ts:98-104
    // assertMatch(payment, {
    //   amount: shares * property.pricePerShare.asUint64(),
    //   receiver: Global.currentApplicationAddress,
    //   sender: Txn.sender,
    //   closeRemainderTo: Global.zeroAddress,
    //   rekeyTo: Global.zeroAddress,
    // }, 'Invalid payment transaction')
    dig 1
    gtxns Amount
    // smart_contracts/FractionalRealEstate/contract.algo.ts:99
    // amount: shares * property.pricePerShare.asUint64(),
    dig 1
    pushint 18 // 18
    intc_0 // 8
    box_extract
    dup
    btoi
    dig 5
    *
    // smart_contracts/FractionalRealEstate/contract.algo.ts:98-104
    // assertMatch(payment, {
    //   amount: shares * property.pricePerShare.asUint64(),
    //   receiver: Global.currentApplicationAddress,
    //   sender: Txn.sender,
    //   closeRemainderTo: Global.zeroAddress,
    //   rekeyTo: Global.zeroAddress,
    // }, 'Invalid payment transaction')
    dig 2
    ==
    dig 4
    gtxns Receiver
    // smart_contracts/FractionalRealEstate/contract.algo.ts:100
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/FractionalRealEstate/contract.algo.ts:98-104
    // assertMatch(payment, {
    //   amount: shares * property.pricePerShare.asUint64(),
    //   receiver: Global.currentApplicationAddress,
    //   sender: Txn.sender,
    //   closeRemainderTo: Global.zeroAddress,
    //   rekeyTo: Global.zeroAddress,
    // }, 'Invalid payment transaction')
    ==
    &&
    dig 4
    gtxns Sender
    // smart_contracts/FractionalRealEstate/contract.algo.ts:101
    // sender: Txn.sender,
    txn Sender
    // smart_contracts/FractionalRealEstate/contract.algo.ts:98-104
    // assertMatch(payment, {
    //   amount: shares * property.pricePerShare.asUint64(),
    //   receiver: Global.currentApplicationAddress,
    //   sender: Txn.sender,
    //   closeRemainderTo: Global.zeroAddress,
    //   rekeyTo: Global.zeroAddress,
    // }, 'Invalid payment transaction')
    ==
    &&
    dig 4
    gtxns CloseRemainderTo
    // smart_contracts/FractionalRealEstate/contract.algo.ts:102
    // closeRemainderTo: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/FractionalRealEstate/contract.algo.ts:98-104
    // assertMatch(payment, {
    //   amount: shares * property.pricePerShare.asUint64(),
    //   receiver: Global.currentApplicationAddress,
    //   sender: Txn.sender,
    //   closeRemainderTo: Global.zeroAddress,
    //   rekeyTo: Global.zeroAddress,
    // }, 'Invalid payment transaction')
    ==
    &&
    uncover 4
    gtxns RekeyTo
    // smart_contracts/FractionalRealEstate/contract.algo.ts:103
    // rekeyTo: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/FractionalRealEstate/contract.algo.ts:98-104
    // assertMatch(payment, {
    //   amount: shares * property.pricePerShare.asUint64(),
    //   receiver: Global.currentApplicationAddress,
    //   sender: Txn.sender,
    //   closeRemainderTo: Global.zeroAddress,
    //   rekeyTo: Global.zeroAddress,
    // }, 'Invalid payment transaction')
    ==
    &&
    assert // Invalid payment transaction
    // smart_contracts/FractionalRealEstate/contract.algo.ts:105
    // assert(shares <= property.availableShares.asUint64(), 'Not enough shares')
    dig 2
    pushint 10 // 10
    intc_0 // 8
    box_extract
    btoi
    dig 4
    dig 1
    <=
    assert // Not enough shares
    // smart_contracts/FractionalRealEstate/contract.algo.ts:108
    // const asset = Asset(property.propertyAssetId.asUint64())
    dig 3
    pushint 26 // 26
    intc_0 // 8
    box_extract
    dup
    btoi
    // smart_contracts/FractionalRealEstate/contract.algo.ts:109-121
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: shares,
    //     fee: 0,
    //   }),
    //   itxn.payment({
    //     amount: payment.amount,
    //     receiver: property.ownerAddress.bytes,
    //     fee: 0,
    //   }),
    // )
    itxn_begin
    // smart_contracts/FractionalRealEstate/contract.algo.ts:112
    // assetReceiver: Txn.sender,
    txn Sender
    dig 7
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/FractionalRealEstate/contract.algo.ts:110-115
    // itxn.assetTransfer({
    //   xferAsset: asset,
    //   assetReceiver: Txn.sender,
    //   assetAmount: shares,
    //   fee: 0,
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/FractionalRealEstate/contract.algo.ts:114
    // fee: 0,
    intc_2 // 0
    itxn_field Fee
    // smart_contracts/FractionalRealEstate/contract.algo.ts:116-120
    // itxn.payment({
    //   amount: payment.amount,
    //   receiver: property.ownerAddress.bytes,
    //   fee: 0,
    // }),
    itxn_next
    // smart_contracts/FractionalRealEstate/contract.algo.ts:118
    // receiver: property.ownerAddress.bytes,
    dig 4
    pushint 34 // 34
    intc_3 // 32
    box_extract
    dup
    itxn_field Receiver
    uncover 4
    itxn_field Amount
    // smart_contracts/FractionalRealEstate/contract.algo.ts:116-120
    // itxn.payment({
    //   amount: payment.amount,
    //   receiver: property.ownerAddress.bytes,
    //   fee: 0,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/FractionalRealEstate/contract.algo.ts:119
    // fee: 0,
    intc_2 // 0
    itxn_field Fee
    // smart_contracts/FractionalRealEstate/contract.algo.ts:109-121
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: shares,
    //     fee: 0,
    //   }),
    //   itxn.payment({
    //     amount: payment.amount,
    //     receiver: property.ownerAddress.bytes,
    //     fee: 0,
    //   }),
    // )
    itxn_submit
    // smart_contracts/FractionalRealEstate/contract.algo.ts:123
    // this.updateAvailableShares(propertyId, property.availableShares.asUint64() - shares)
    uncover 2
    uncover 5
    -
    // smart_contracts/FractionalRealEstate/contract.algo.ts:147
    // const propertyStruct = clone(this.listedProperties(propertyId).value)
    dig 4
    box_get
    pop
    // smart_contracts/FractionalRealEstate/contract.algo.ts:149
    // ...propertyStruct,
    dup
    intc_2 // 0
    extract_uint16
    dig 1
    len
    substring3
    dig 5
    pushint 2 // 2
    intc_0 // 8
    box_extract
    // smart_contracts/FractionalRealEstate/contract.algo.ts:150
    // availableShares: new arc4.Uint64(newAvailableShares),
    uncover 2
    itob
    // smart_contracts/FractionalRealEstate/contract.algo.ts:148-151
    // const updatedStruct = new PropertyStruct({
    //   ...propertyStruct,
    //   availableShares: new arc4.Uint64(newAvailableShares),
    // })
    bytec_1 // 0x0042
    uncover 2
    concat
    swap
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/FractionalRealEstate/contract.algo.ts:153
    // this.listedProperties(propertyId).value = clone(updatedStruct)
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/FractionalRealEstate/contract.algo.ts:92
    // public purchaseFromLister(propertyId: uint64, shares: uint64, payment: gtxn.PaymentTxn): boolean {
    pushbytes 0x151f7c7580
    log
    intc_1 // 1
    return


// smart_contracts/FractionalRealEstate/contract.algo.ts::FractionalRealEstate.delistProperty[routing]() -> void:
delistProperty:
    // smart_contracts/FractionalRealEstate/contract.algo.ts:130
    // public delistProperty(propertyId: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/FractionalRealEstate/contract.algo.ts:131
    // assert(this.listedProperties(propertyId).exists, 'Property not listed')
    itob
    // smart_contracts/FractionalRealEstate/contract.algo.ts:28
    // public listedProperties = BoxMap<uint64, PropertyStruct>({ keyPrefix: 'properties' })
    bytec_0 // "properties"
    swap
    concat
    // smart_contracts/FractionalRealEstate/contract.algo.ts:131
    // assert(this.listedProperties(propertyId).exists, 'Property not listed')
    dup
    box_len
    bury 1
    assert // Property not listed
    // smart_contracts/FractionalRealEstate/contract.algo.ts:135
    // assert(Txn.sender === property.ownerAddress.native, 'Only the owner can delist')
    txn Sender
    dig 1
    pushint 34 // 34
    intc_3 // 32
    box_extract
    ==
    assert // Only the owner can delist
    // smart_contracts/FractionalRealEstate/contract.algo.ts:137
    // property.availableShares.asUint64() === property.totalShares.asUint64(),
    dup
    pushint 10 // 10
    intc_0 // 8
    box_extract
    btoi
    dig 1
    pushint 2 // 2
    intc_0 // 8
    box_extract
    btoi
    ==
    // smart_contracts/FractionalRealEstate/contract.algo.ts:136-139
    // assert(
    //   property.availableShares.asUint64() === property.totalShares.asUint64(),
    //   'Cannot delist property with sold shares',
    // )
    assert // Cannot delist property with sold shares
    // smart_contracts/FractionalRealEstate/contract.algo.ts:141
    // this.listedProperties(propertyId).delete()
    box_del
    pop
    // smart_contracts/FractionalRealEstate/contract.algo.ts:130
    // public delistProperty(propertyId: uint64): void {
    intc_1 // 1
    return


// smart_contracts/FractionalRealEstate/contract.algo.ts::FractionalRealEstate.getPropertyInfo[routing]() -> void:
getPropertyInfo:
    // smart_contracts/FractionalRealEstate/contract.algo.ts:156
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/FractionalRealEstate/contract.algo.ts:158
    // assert(this.listedProperties(propertyId).exists, 'Property not listed')
    itob
    // smart_contracts/FractionalRealEstate/contract.algo.ts:28
    // public listedProperties = BoxMap<uint64, PropertyStruct>({ keyPrefix: 'properties' })
    bytec_0 // "properties"
    swap
    concat
    // smart_contracts/FractionalRealEstate/contract.algo.ts:158
    // assert(this.listedProperties(propertyId).exists, 'Property not listed')
    dup
    box_len
    bury 1
    assert // Property not listed
    // smart_contracts/FractionalRealEstate/contract.algo.ts:159
    // return this.listedProperties(propertyId).value
    box_get
    pop
    // smart_contracts/FractionalRealEstate/contract.algo.ts:156
    // @abimethod({ readonly: true })
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
